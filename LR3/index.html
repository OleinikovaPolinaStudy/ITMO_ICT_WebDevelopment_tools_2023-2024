<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>LR3 - Docs</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">Docs</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href=".." class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../LR1/" class="nav-link">LR1</a>
                            </li>
                            <li class="navitem">
                                <a href="../LR2/" class="nav-link">LR2</a>
                            </li>
                            <li class="navitem active">
                                <a href="./" class="nav-link">LR3</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../LR2/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" class="nav-link disabled">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#3-fastapi-docker" class="nav-link">Лабораторная работа 3: Упаковка FastAPI приложения в Docker, Работа с источниками данных и Очереди</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#_1" class="nav-link">Описание задания</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_6" class="nav-link">Выполнение</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#rest" class="nav-link">Упаковка rest</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_7" class="nav-link">Упаковка парсера</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#docker-compose" class="nav-link">docker-compose</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_8" class="nav-link">Результат</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="3-fastapi-docker">Лабораторная работа 3: Упаковка FastAPI приложения в Docker, Работа с источниками данных и Очереди</h1>
<h2 id="_1">Описание задания</h2>
<h3 id="_2">Цель</h3>
<p>Научиться упаковывать FastAPI приложение в Docker, интегрировать парсер данных с базой данных и вызывать парсер через API и очередь.</p>
<p>Задачи 1 и 2 - задачи на минимум для сдачи - 70% баллов. Задачи 1, 2 и 3 - 100% баллов.</p>
<h3 id="1-fastapi-docker">Подзадача 1: Упаковка FastAPI приложения, базы данных и парсера данных в Docker</h3>
<p>Docker — это платформа для разработки, доставки и запуска приложений в контейнерах. Контейнеры позволяют упаковать приложение и все его зависимости в единый образ, который можно запускать на любой системе, поддерживающей Docker, что обеспечивает консистентность среды выполнения и упрощает развертывание. Docker помогает ускорить разработку, повысить гибкость и масштабируемость приложений. Материалы: [Основы работы с Docker](<a href="https://tproger.ru/translations/how-to-start-using-docker">https://tproger.ru/translations/docker-for-beginners/</a>.</p>
<ol>
<li>
<p><strong>Создание FastAPI приложения</strong>:
   Создано в рамках лабораторной работы номер 1</p>
</li>
<li>
<p><strong>Создание базы данных</strong>:
   Создано в рамках лабораторной работы номер 1</p>
</li>
<li>
<p><strong>Создание парсера данных</strong>:
   Создано в рамках лабораторной работы номер 2</p>
</li>
<li>
<p><strong>Реулизуйте возможность вызова парсера по http</strong>
   Для этого можно сделать отдельное приложение FastAPI для парсера или воспользоваться библиотекой socket или подобными.</p>
</li>
</ol>
<p>Пример кода:</p>
<pre><code>from fastapi import FastAPI, HTTPException
...

app = FastAPI()

@app.post(&quot;/parse&quot;)
def parse(url: str):
    try:
        response = requests.get(url)
        response.raise_for_status()
        # Вызов парсера
        return {&quot;message&quot;: &quot;Parsing completed&quot;, ...}
    except requests.RequestException as e:
        raise HTTPException(status_code=500, detail=str(e))
</code></pre>
<ol>
<li><strong>Разработка Dockerfile</strong>:</li>
<li>Необходимо создать Dockerfile для упаковки FastAPI приложения и приложения с паресером. В Dockerfile указать базовый образ, установить необходимые зависимости, скопировать исходные файлы в контейнер и определить команду для запуска приложения.</li>
<li><strong>Зачем</strong>: Docker позволяет упаковать приложение и все его зависимости в единый контейнер, что обеспечивает консистентность среды выполнения и упрощает развертывание.</li>
<li>
<p>Полезные ссылки:</p>
<ul>
<li><a href="https://fastapi.tiangolo.com/ru/deployment/docker/">FastAPI и Docker-контейнеры</a></li>
<li><a href="https://habr.com/ru/articles/578744/">Запускаем PostgreSQL в Docker: от простого к сложному</a></li>
<li>
<ul>
<li><a href="https://docs.docker.com/engine/reference/builder/">Документация Dockerfile</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Создание Docker Compose файла</strong>:</p>
</li>
<li>Необходимо написать docker-compose.yml для управления оркестром сервисов, включающих FastAPI приложение, базу данных и парсер данных. Определите сервисы, укажите порты и зависимости между сервисами.</li>
<li><strong>Зачем</strong>: Docker Compose упрощает управление несколькими контейнерами, позволяя вам запускать и настраивать все сервисы вашего приложения с помощью одного файла конфигурации.</li>
<li>Полезные ссылки:<ul>
<li><a href="https://rebrainme.com/blog/kubernetes/zachem-nuzhny-sistemy-orkestraczii/">Зачем нужны системы оркестрации?</a></li>
<li><a href="https://dev.to/abbazs/developing-a-fastapi-application-in-a-docker-container-31n4">Developing a FastAPI Application in a Docker Container</a></li>
<li><a href="https://docs.docker.com/compose/">Документация Docker Compose</a></li>
</ul>
</li>
</ol>
<h3 id="2-fastapi">Подзадача 2: Вызов парсера из FastAPI</h3>
<ol>
<li>** Эндпоинт в FastAPI для вызова парсера**:</li>
<li>Необходимо добавить в FastAPI приложение ендпоинт, который будет принимать запросы с URL для парсинга <strong>от клиента</strong>, отправлять запрос парсеру (запущенному в отдельном контейнере) и возвращать ответ с результатом <strong>клиенту</strong>.</li>
<li><strong>Зачем</strong>: Это позволит интегрировать функциональность парсера в ваше веб-приложение, предоставляя возможность пользователям запускать парсинг через API.</li>
<li>Полезные ссылки:<ul>
<li><a href="https://fastapi.tiangolo.com/tutorial/path-params/">Документация FastAPI</a></li>
</ul>
</li>
</ol>
<h3 id="3-fastapi">Подзадача 3: Вызов парсера из FastAPI через очередь</h3>
<h3 id="_3">Как это работает</h3>
<ol>
<li><strong>Celery и Redis</strong>:</li>
<li>Celery — это асинхронная очередь задач, которая позволяет легко распределять и выполнять задачи в фоне. Redis используется как брокер сообщений, хранящий задачи, которые должны быть выполнены.</li>
<li>
<p>При получении HTTP-запроса, задача ставится в очередь Redis, и Celery-воркер обрабатывает её в фоне.</p>
</li>
<li>
<p><strong>Docker Compose</strong>:</p>
</li>
<li>Docker Compose позволяет легко настроить и запустить Celery, Redis и ваше FastAPI приложение как отдельные контейнеры, работающие в одной сети. Это упрощает управление зависимостями и конфигурацией всех компонентов системы.</li>
</ol>
<h3 id="_4">Почему это важно для студентов</h3>
<p>Практические навыки настройки и использования асинхронной очереди задач в реальном приложении - <strong>первый шаг для MLops для 45 направления</strong>. Студенты научатся разделять ответственность между различными сервисами и компоновать их для достижения общей цели. В реальных проектах часто требуется выполнение сложных и длительных операций. Опыт работы с Celery и Redis подготовит к решению таких задач и даст уверенность в использовании современных технологий.</p>
<h3 id="_5">Задание</h3>
<ol>
<li><strong>Установить Celery и Redis</strong>:</li>
<li>Необходимо добавить зависимости для Celery и Redis в проект. Celery будет использоваться для обработки задач в фоне, а Redis будет выступать в роли брокера задач и хранилища результатов.</li>
<li><strong>Зачем</strong>: Celery и Redis позволяют организовать фоновую обработку задач, что полезно для выполнения длительных или ресурсоемких операций без блокировки основного потока выполнения.</li>
<li>
<p>Полезные ссылки:</p>
<ul>
<li><a href="https://habr.com/ru/articles/686820/">Celery: проясняем неочевидные моменты</a></li>
<li><a href="https://docs.celeryproject.org/en/stable/">Документация Celery</a></li>
<li><a href="https://redis.io/documentation">Документация Redis</a></li>
</ul>
</li>
<li>
<p><strong>Настроить Celery</strong>:</p>
</li>
<li>необходимо создать файл конфигурации для Celery. Определть задачу для парсинга URL, которая будет выполняться в фоновом режиме.</li>
<li><strong>Зачем</strong>: Настройка Celery позволит асинхронно обрабатывать задачи, что улучшит производительность и отзывчивость вашего приложения.</li>
<li>
<p>Полезные ссылки:</p>
<ul>
<li><a href="https://docs.celeryproject.org/en/stable/userguide/configuration.html">Документация Celery: Настройка</a></li>
</ul>
</li>
<li>
<p><strong>Обновить Docker Compose файл</strong>:</p>
</li>
<li>Необходимо добавить сервисы для Redis и Celery worker в docker-compose.yml. Определите зависимости между сервисами, чтобы обеспечить корректную работу оркестра.</li>
<li><strong>Зачем</strong>: Это позволит вам легко управлять всеми сервисами вашего приложения, включая асинхронную обработку задач, с помощью одного файла конфигурации.</li>
<li>
<p>Полезные ссылки:</p>
<ul>
<li><a href="https://docs.docker.com/compose/">Документация Docker Compose</a></li>
</ul>
</li>
<li>
<p><strong>Эндпоинт для асинхронного вызова парсера</strong>:</p>
</li>
<li>Необходимо добавить в FastAPI приложение маршрут для асинхронного вызова парсера. Маршрут должен принимать запросы с URL для парсинга, ставить задачу в очередь с помощью Celery и возвращать ответ о начале выполнения задачи.</li>
<li><strong>Зачем</strong>: Это позволит запускать парсинг веб-страниц в фоне, что улучшит производительность и пользовательский опыт вашего приложения.</li>
<li>Полезные ссылки:<ul>
<li><a href="https://fastapi.tiangolo.com/tutorial/background-tasks/">Документация FastAPI: Фоновая задачи</a></li>
</ul>
</li>
</ol>
<h2 id="_6">Выполнение</h2>
<h2 id="rest">Упаковка rest</h2>
<p>Dockerfile</p>
<pre><code>FROM python:3.9.19-alpine3.20

WORKDIR /app

COPY requirements.txt .

RUN pip install --no-cache-dir --upgrade -r requirements.txt

COPY . .

EXPOSE 8000

CMD [&quot;uvicorn&quot;, &quot;main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;8000&quot;]
</code></pre>
<p>FROM python:3.9.19-alpine3.20 Эта строка указывает базовый образ для Docker образа.</p>
<p>WORKDIR /app Эта команда устанавливает рабочую директорию внутри контейнера Docker в /app. Все последующие команды будут выполняться в этой директории.</p>
<p>COPY requirements.txt . Эта команда копирует файл requirements.txt из текущей директории на вашем компьютере в текущую рабочую директорию контейнера Docker (/app).</p>
<p>RUN pip install --no-cache-dir --upgrade -r requirements.txt Эта команда запускает установку зависимостей Python, указанных в файле requirements.txt, используя пакетный менеджер pip. Флаг --no-cache-dir предотвращает сохранение временных файлов установки, что уменьшает размер конечного образа Docker. Флаг --upgrade обновляет все пакеты до последних версий, если это возможно.</p>
<p>COPY . . Эта команда копирует все файлы и директории из текущей директории на вашем компьютере в текущую рабочую директорию контейнера Docker (/app).</p>
<p>EXPOSE 8000 Эта команда указывает Docker, что контейнер будет прослушивать порт 8000. Это не открывает порт, но позволяет другим разработчикам понимать, какой порт используется.</p>
<p>CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"] Эта команда указывает, что нужно выполнить при запуске контейнера. В данном случае, это запуск сервера uvicorn с приложением, определенным в файле main.py.</p>
<p>requirements</p>
<pre><code>fastapi
uvicorn
pydantic
sqlmodel
passlib
requests
pyjwt
starlette
sqlalchemy
psycopg2-binary
python-dotenv
httpx
</code></pre>
<h2 id="_7">Упаковка парсера</h2>
<h3 id="celery_worker">celery_worker</h3>
<pre><code>from celery_app import celery_app

if __name__ == &quot;__main__&quot;:
    celery_app.start()
</code></pre>
<p>Запускаем celery</p>
<h3 id="celery_app">celery_app</h3>
<pre><code>from celery import Celery

celery_app = Celery(
    &quot;worker&quot;,
    broker=&quot;redis://redis:6379/0&quot;,
    backend=&quot;redis://redis:6379/0&quot;,
)

celery_app.conf.update(
    task_routes={
        &quot;tasks.parse_url_task&quot;: &quot;main-queue&quot;,
    },
)
</code></pre>
<p>Инициализируем Celery приложение с именем worker и настраиваем его для использования Redis как брокера и backend. Также обновляем конфигурацию Celery для маршрутизации задачи parse_url_task в main-queue.</p>
<h3 id="tasks">tasks</h3>
<pre><code>import requests
from bs4 import BeautifulSoup
from celery_app import celery_app
from connection import DataBaseConnection


def get_bio(url):
    response = requests.get(url)
    html = response.text
    soup = BeautifulSoup(html, 'html.parser')
    text = soup.find('div', class_='xZmPc')
    bio_container = text.find('div')
    if bio_container.em and bio_container.em.text:
        return bio_container.em.text
    if bio_container.text:
        return bio_container.text

@celery_app.task
def parse_url_task(url: str):
    response = requests.get(url)
    response.raise_for_status()
    html = response.text
    soup = BeautifulSoup(html, 'html.parser')
    db_conn = DataBaseConnection.connect_to_database()

    tasks = soup.find_all('div', class_='CHPy6')
    for task in tasks:
        name = task.find('div', class_='dbENL').text + ' ' + task.find('div', class_='p1Gbz').text
        bio = get_bio('https://www.culture.ru' + task.a['href'])

        with db_conn.cursor() as cursor:
                cursor.execute(DataBaseConnection.INSERT_SQL, (name, bio))

    db_conn.commit()
</code></pre>
<p>Определяем задачу Celery parse_url_task, которая парсит страницу и записывает авторов в базу данных.</p>
<h3 id="main">main</h3>
<pre><code>from fastapi import FastAPI, BackgroundTasks
from pydantic import BaseModel
from tasks import parse_url_task

app = FastAPI()

class URLItem(BaseModel):
    url: str

@app.post(&quot;/parse-url/&quot;)
async def parse_url(item: URLItem, background_tasks: BackgroundTasks):
    background_tasks.add_task(parse_url_task, item.url)
    return {&quot;message&quot;: &quot;URL parsing has been started in the background.&quot;}


@app.get(&quot;/&quot;)
async def read_root():
    return {&quot;message&quot;: &quot;Welcome to the URL parser API!&quot;}
</code></pre>
<p>Создаем экземпляр класса FastAPI. Определяем модель Pydantic для проверки входящих данных URL. Определяем POST конечную точку /parse-url/, которая принимает URL и запускает фоновую задачу для его анализа. Определяем корневую GET конечную точку /, которая возвращает приветственное сообщение.</p>
<h3 id="dockerfile">Dockerfile</h3>
<pre><code>FROM python:3.9.19-alpine3.20

WORKDIR /app

COPY requirements.txt .

RUN pip install --no-cache-dir --upgrade -r requirements.txt

COPY . .

EXPOSE 3000

CMD [&quot;uvicorn&quot;, &quot;main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;3000&quot;]
</code></pre>
<p>Аналогично rest</p>
<h3 id="requirements">requirements</h3>
<pre><code>fastapi
uvicorn
pydantic
celery
redis
requests
bs4
psycopg2-binary
python-dotenv
</code></pre>
<h2 id="docker-compose">docker-compose</h2>
<pre><code>version: '3.9'

services:
  celery_app:
    build:
      context: ./celery
      dockerfile: Dockerfile
    container_name: celery
    restart: always
    ports:
      - &quot;3000:3000&quot;
    env_file:
      - .env
    depends_on:
      - redis

  celery_worker:
    build:
      context: ./celery
    container_name: celery_worker
    command: celery -A celery_worker worker --loglevel=info
    restart: always
    depends_on:
      - redis
      - celery_app

  redis:
    image: redis:7.2.4
    container_name: redis
    ports:
      - &quot;6379:6379&quot;
    restart: always

  rest:
    build: ./rest
    container_name: rest
    ports:
      - &quot;8000:8000&quot;
    env_file:
      - ./rest/.env
    depends_on:
      - db
      - celery_app

  db:
    image: postgres:latest
    container_name: db
    ports:
      - &quot;5432:5432&quot;
    environment:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASS}
      POSTGRES_DB: ${DB_NAME}
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
</code></pre>
<p>Этот код представляет собой файл <strong>docker-compose.yml</strong>, который используется для определения и запуска многоконтейнерного приложения с использованием Docker Compose. Давайте разберемся, что происходит в каждой строке кода.</p>
<p><strong>version: '3.9'</strong></p>
<ul>
<li>Указывает версию Docker Compose, которую нужно использовать для интерпретации файла.  Версия 3.9 гарантирует, что все функции и возможности Docker Compose, которые используются в файле, будут корректно интерпретированы.</li>
</ul>
<p><strong>services:</strong></p>
<ul>
<li>Этот раздел определяет отдельные сервисы, которые составляют ваше приложение. В данном случае у вас 6 сервисов: <code>celery_app</code>, <code>celery_worker</code>, <code>redis</code>, <code>rest</code>, <code>db</code>, каждый из которых представляет отдельный контейнер Docker.</li>
</ul>
<p><strong>celery_app:</strong></p>
<ul>
<li><strong>build:</strong><ul>
<li><strong>context: ./celery:</strong> Указывает на директорию, где расположен файл Dockerfile для построения образа этого сервиса.</li>
<li><strong>dockerfile: Dockerfile:</strong>  Определяет имя Dockerfile, которое используется для построения образа.</li>
</ul>
</li>
<li><strong>container_name: celery:</strong> Задает имя контейнера.</li>
<li><strong>restart: always:</strong> Контейнер будет автоматически перезапускаться при сбое.</li>
<li><strong>ports:</strong><ul>
<li><strong>"3000:3000"</strong>:  Перенаправляет порт 3000 из контейнера на порт 3000 на хост-машине, позволяя доступ к сервису извне.</li>
</ul>
</li>
<li><strong>env_file:</strong><ul>
<li><strong>- .env:</strong> Использует файл <code>.env</code> для загрузки переменных окружения в контейнер.</li>
</ul>
</li>
<li><strong>depends_on:</strong><ul>
<li><strong>- redis:</strong> Определяет, что сервис <code>celery_app</code> зависит от сервиса <code>redis</code>. Это означает, что контейнер <code>celery_app</code> будет запущен только после того, как контейнер <code>redis</code> будет запущен и готов к работе.</li>
</ul>
</li>
</ul>
<p><strong>celery_worker:</strong></p>
<ul>
<li><strong>build:</strong><ul>
<li><strong>context: ./celery:</strong>  Использует тот же Dockerfile, что и сервис <code>celery_app</code>, чтобы построить образ.</li>
</ul>
</li>
<li><strong>container_name: celery_worker:</strong>  Название контейнера.</li>
<li><strong>command: celery -A celery_worker worker --loglevel=info:</strong> Определяет команду, которую нужно выполнить при запуске контейнера. В данном случае это запуск Celery worker с определенными настройками.</li>
<li><strong>restart: always:</strong>  Контейнер перезапускается при сбое.</li>
<li><strong>depends_on:</strong><ul>
<li><strong>- redis:</strong>  Этот сервис зависит от <code>redis</code>.</li>
<li><strong>- celery_app:</strong>  Также зависит от <code>celery_app</code>,  что логично, так как для работы worker-а требуется Celery app.</li>
</ul>
</li>
</ul>
<p><strong>redis:</strong></p>
<ul>
<li><strong>image: redis:7.2.4:</strong> Использует готовый Docker образ <code>redis:7.2.4</code>  для запуска Redis сервера.</li>
<li><strong>container_name: redis:</strong>  Название контейнера.</li>
<li><strong>ports:</strong><ul>
<li><strong>"6379:6379"</strong>: Перенаправление портов.</li>
</ul>
</li>
<li><strong>restart: always:</strong>  Автоматический перезапуск.</li>
</ul>
<p><strong>rest:</strong></p>
<ul>
<li><strong>build:</strong><ul>
<li><strong>./rest:</strong>  Использует Dockerfile из директории <code>rest</code> для построения образа.</li>
</ul>
</li>
<li><strong>container_name: rest:</strong>  Название контейнера.</li>
<li><strong>ports:</strong><ul>
<li><strong>"8000:8000"</strong>:  Перенаправление портов.</li>
</ul>
</li>
<li><strong>env_file:</strong><ul>
<li><strong>- ./rest/.env:</strong>  Используется файл <code>.env</code> для загрузки переменных окружения для сервиса <code>rest</code>.</li>
</ul>
</li>
<li><strong>depends_on:</strong><ul>
<li><strong>- db:</strong>  Зависит от сервиса <code>db</code>.</li>
<li><strong>- celery_app:</strong> Зависит от сервиса <code>celery_app</code>.</li>
</ul>
</li>
</ul>
<p><strong>db:</strong></p>
<ul>
<li><strong>image: postgres:latest:</strong>  Использует  образ  <code>postgres:latest</code> для запуска PostgreSQL сервера.</li>
<li><strong>container_name: db:</strong>  Название контейнера.</li>
<li><strong>ports:</strong><ul>
<li><strong>"5432:5432"</strong>: Перенаправление портов.</li>
</ul>
</li>
<li><strong>environment:</strong><ul>
<li><strong>POSTGRES_USER: ${DB_USER}</strong>:  Устанавливает имя пользователя  PostgreSQL из переменной окружения  <code>DB_USER</code>.</li>
<li><strong>POSTGRES_PASSWORD: ${DB_PASS}</strong>:  Устанавливает  пароль  из  переменной <code>DB_PASS</code>.</li>
<li><strong>POSTGRES_DB: ${DB_NAME}</strong>:  Устанавливает имя базы данных  из переменной <code>DB_NAME</code>.</li>
</ul>
</li>
<li><strong>volumes:</strong><ul>
<li><strong>- postgres_data:/var/lib/postgresql/data:</strong>  Определяет volume <code>postgres_data</code>, который будет монтироваться в директорию <code>/var/lib/postgresql/data</code> в контейнере <code>db</code>. Это позволит сохранять данные базы данных даже после остановки контейнера.</li>
</ul>
</li>
</ul>
<p><strong>volumes:</strong></p>
<ul>
<li><strong>postgres_data:</strong>  Определяет volume, который используется для хранения данных базы данных PostgreSQL.</li>
</ul>
<p><strong>В целом, этот код:</strong></p>
<ul>
<li>Определяет 6 сервисов, каждый из которых представляет собой отдельный контейнер Docker.</li>
<li>Устанавливает зависимости между сервисами, обеспечивая корректный запуск.</li>
<li>Перенаправляет порты, чтобы сервисы были доступны извне.</li>
<li>Загружает переменные окружения из файлов <code>.env</code>.</li>
<li>Использует volumes для сохранения данных.</li>
</ul>
<h2 id="_8">Результат</h2>
<p><img alt="alt text" src="../image-8.png" />
<img alt="alt text" src="../image-7.png" /></p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/jquery-3.6.0.min.js"></script>
        <script src="../js/bootstrap.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
