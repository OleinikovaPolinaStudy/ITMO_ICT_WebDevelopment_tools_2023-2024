{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u041c\u0438\u043d\u0438\u0441\u0442\u0435\u0440\u0441\u0442\u0432\u043e \u043d\u0430\u0443\u043a\u0438 \u0438 \u0432\u044b\u0441\u0448\u0435\u0433\u043e \u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0420\u043e\u0441\u0441\u0438\u0439\u0441\u043a\u043e\u0439 \u0424\u0435\u0434\u0435\u0440\u0430\u0446\u0438\u0438 \u0444\u0435\u0434\u0435\u0440\u0430\u043b\u044c\u043d\u043e\u0435 \u0433\u043e\u0441\u0443\u0434\u0430\u0440\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0435 \u0430\u0432\u0442\u043e\u043d\u043e\u043c\u043d\u043e\u0435 \u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0435 \u0443\u0447\u0440\u0435\u0436\u0434\u0435\u043d\u0438\u0435 \u0432\u044b\u0441\u0448\u0435\u0433\u043e \u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u00ab\u041d\u0410\u0426\u0418\u041e\u041d\u0410\u041b\u042c\u041d\u042b\u0419 \u0418\u0421\u0421\u041b\u0415\u0414\u041e\u0412\u0410\u0422\u0415\u041b\u042c\u0421\u041a\u0418\u0419 \u0423\u041d\u0418\u0412\u0415\u0420\u0421\u0418\u0422\u0415\u0422 \u0418\u0422\u041c\u041e\u00bb \u041e\u0422\u0427\u0415\u0422 \u043f\u043e \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u0435 \u00ab\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u043e\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f FastAPI\u00bb \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 \u00abWeb-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435\u00bb \u041e\u0442\u0447\u0435\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u043b\u0430 \u0421\u0442\u0443\u0434\u0435\u043d\u0442\u043a\u0430: \u041e\u043b\u0435\u0439\u043d\u0438\u043a\u043e\u0432\u0430 \u041f\u043e\u043b\u0438\u043d\u0430 \u0413\u0440\u0443\u043f\u043f\u0430: \u041a33402 \u0424\u0430\u043a\u0443\u043b\u044c\u0442\u0435\u0442: \u0418\u041a\u0422 \u041f\u0440\u0435\u043f\u043e\u0434\u0430\u0432\u0430\u0442\u0435\u043b\u044c: \u0413\u043e\u0432\u043e\u0440\u043e\u0432 \u0410\u043d\u0442\u043e\u043d \u0421\u0430\u043d\u043a\u0442-\u041f\u0435\u0442\u0435\u0440\u0431\u0443\u0440\u0433 2024","title":"Home"},{"location":"LR1/","text":"https://github.com/OleinikovaPolinaStudy/ITMO_ICT_WebDevelopment_tools_2023-2024/tree/laboratory_work_1 Models book exchange class StatusType(Enum): notconsidered = \"not considered\" accepted = \"accepted\" rejected = \"rejected\" class BookExchangeBase(SQLModel): book_instance_id: Optional[int] = Field(default=None, foreign_key=\"bookinstance.id\") status: StatusType date_start: datetime.datetime date_end: datetime.datetime class BookExchange(BookExchangeBase, table=True): id: int = Field(default=None, primary_key=True) sender_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") receiver_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") sender: Optional[\"User\"] = Relationship( back_populates=\"sender_requests\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.sender_id]\"), ) receiver: Optional[\"User\"] = Relationship( back_populates=\"receiver_requests\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.receiver_id]\"), ) book_instance: Optional[\"BookInstance\"] = Relationship( back_populates=\"requests\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.book_instance_id]\"), ) class BookExchangeChangeStatus(SQLModel): status: StatusType class BookExchangeRead(BookExchangeBase): id: int sender_id: int receiver_id: int class BookExchangeReadFull(BookExchangeRead): sender: \"UserBase\" = None receiver: \"UserBase\" = None book_instance: \"BookInstanceWithBook\" = None book instance class BookInstanceBase(SQLModel): book_id: Optional[int] = Field(default=None, foreign_key=\"book.id\") date: datetime.datetime publisher: str features: str class BookInstance(BookInstanceBase, table=True): id: int = Field(default=None, primary_key=True) owner_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") requests: Optional[List[\"BookExchange\"]] = Relationship( back_populates=\"book_instance\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.book_instance_id]\"), ) book: Optional[\"Book\"] = Relationship(back_populates=\"instances\") owner: Optional[\"User\"] = Relationship(back_populates=\"instances\") class BookInstanceRead(BookInstanceBase): id: int owner_id: int class BookInstanceWithBook(BookInstanceRead): book: \"BookRead\" = None class BookInstanceReadFull(BookInstanceWithBook): requests: list[\"BookExchangeRead\"] = [] owner: \"UserBase\" = None author class AuthorBase(SQLModel): name: str bio: str class Author(AuthorBase, table=True): id: int = Field(default=None, primary_key=True) books: Optional[List[\"Book\"]] = Relationship(back_populates=\"author\") class AuthorRead(AuthorBase): id: int class AuthorReadFull(AuthorRead): books: list[\"BookRead\"] = [] book class BookBase(SQLModel): title: str description: str author_id: Optional[int] = Field(default=None, foreign_key=\"author.id\") class Book(BookBase, table=True): id: int = Field(default=None, primary_key=True) author: Optional[Author] = Relationship(back_populates=\"books\") owners: Optional[List[\"User\"]] = Relationship(back_populates=\"books\", link_model=BookInstance) instances: Optional[List[\"BookInstance\"]] = Relationship(back_populates=\"book\") class BookRead(BookBase): id: int class BookReadFull(BookRead): author: AuthorRead = None owners: list[\"UserBase\"] = [] instances: list[\"BookInstanceRead\"] = [] user class UserBase(SQLModel): id: int = Field(primary_key=True) username: str = Field(index=True) name: str about: str email: EmailStr = Field(unique=True, index=True, sa_type=AutoString) class User(UserBase, table=True): password: str = Field(max_length=256, min_length=6) created_at: datetime.datetime = datetime.datetime.now() books: Optional[List[\"Book\"]] = Relationship(back_populates=\"owners\", link_model=BookInstance) sender_requests: Optional[List[\"BookExchange\"]] = Relationship( back_populates=\"sender\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.sender_id]\"), ) receiver_requests: Optional[List[\"BookExchange\"]] = Relationship( back_populates=\"receiver\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.receiver_id]\"), ) instances: Optional[List[\"BookInstance\"]] = Relationship(back_populates=\"owner\") class UserReadFull(UserBase): sender_requests: list[\"BookExchangeRead\"] = [] receiver_requests: list[\"BookExchangeRead\"] = [] instances: list[\"BookInstanceWithBook\"] = [] class UserInput(SQLModel): name: str about: str username: str password: str = Field(max_length=256, min_length=6) password2: str email: EmailStr = Field(unique=True, index=True, sa_type=AutoString) @validator('password2') def password_match(cls, v, values, **kwargs): if 'password' in values and v != values['password']: raise ValueError('passwords don\\'t match') return v class UserLogin(SQLModel): username: str password: str class UserPassword(SQLModel): old_password: str new_password: str Endpointes user from fastapi import APIRouter, HTTPException, Depends from starlette.status import HTTP_201_CREATED from auth.auth import AuthHandler from db.connection import get_session from models import UserInput, User, UserLogin, UserPassword, UserReadFull from sqlmodel import select user_router = APIRouter() auth_handler = AuthHandler() @user_router.post('/registration', status_code=201, description='Register new user') def register(user: UserInput, session=Depends(get_session)): users = session.exec(select(User)).all() if any(x.username == user.username for x in users): raise HTTPException(status_code=400, detail='Username is taken') if any(x.email == user.email for x in users): raise HTTPException(status_code=400, detail='Email is taken') hashed_pwd = auth_handler.get_password_hash(user.password) user = User(username=user.username, password=hashed_pwd, email=user.email, name=user.name, about=user.about) session.add(user) session.commit() return {\"status\": 201, \"message\": \"Created\"} @user_router.post('/login') def login(user: UserLogin, session=Depends(get_session)): user_found = session.exec(select(User).where(User.username == user.username)).first() if not user_found: raise HTTPException(status_code=401, detail='Invalid username and/or password') verified = auth_handler.verify_password(user.password, user_found.password) if not verified: raise HTTPException(status_code=401, detail='Invalid username and/or password') token = auth_handler.encode_token(user_found.username) return {'token': token} @user_router.get('/users/me') def get_current_user(user: User = Depends(auth_handler.get_current_user)) -> UserReadFull: return user @user_router.patch(\"/users/me/password\") def user_pwd(user_pwd: UserPassword, session=Depends(get_session), current=Depends(auth_handler.get_current_user)): found_user = session.get(User, current.id) if not found_user: raise HTTPException(status_code=404, detail=\"User not found\") verified = auth_handler.verify(user_pwd.old_password, found_user.password) if not verified: raise HTTPException(status_code=400, detail=\"Invalid old password\") hashed_pwd = auth_handler.get_password_hash(user_pwd.new_password) found_user.password = hashed_pwd session.add(found_user) session.commit() session.refresh(found_user) return {\"status\": 200, \"message\": \"password changed successfully\"} @user_router.get(\"/users\") def user_list(session=Depends(get_session)) -> list[User]: users = session.exec(select(User)).all() user_models = [user.model_dump(exclude={'password'}) for user in users] return user_models @user_router.get(\"/users/{user_id}\") def user_one(user_id: int, session=Depends(get_session)) -> UserReadFull: user = session.get(User, user_id) if not user: raise HTTPException(status_code=404, detail=\"User not found\") return user book from fastapi import APIRouter, HTTPException from sqlmodel import select from fastapi import Depends from models import Book, BookBase, BookReadFull from db.connection import get_session book_router = APIRouter() @book_router.get(\"/\") def get_books(session=Depends(get_session)) -> list[BookReadFull] : return session.exec(select(Book)).all() @book_router.get(\"/{book_id}\") def get_book(book_id: int, session=Depends(get_session)) -> BookReadFull: book = session.get(Book, book_id) if not book: raise HTTPException(status_code=404, detail=\"Book not found\") return book @book_router.post(\"/\") def create_book(book_data: BookBase, session=Depends(get_session)) -> Book: book = Book.model_validate(book_data) session.add(book) session.commit() session.refresh(book) return book @book_router.patch(\"/{book_id}\") def update_book(book_id: int, book_data: BookBase, session=Depends(get_session)) -> Book: book = session.exec(select(Book).where(Book.id == book_id)).first() if not book: raise HTTPException(status_code=404, detail=\"Book not found\") for key, value in book_data.model_dump(exclude_unset=True).items(): setattr(book, key, value) session.add(book) session.commit() session.refresh(book) return book @book_router.delete(\"/{book_id}\") def delete_book(book_id: int, session=Depends(get_session)): book = session.exec(select(Book).where(Book.id == book_id)).first() if not book: raise HTTPException(status_code=404, detail=\"Book not found\") session.delete(book) session.commit() return {\"ok\": True} book instance from fastapi import APIRouter, HTTPException from sqlmodel import select from fastapi import Depends from models import BookInstance, BookInstanceBase, BookInstanceReadFull from db.connection import get_session from auth.auth import AuthHandler book_instance_router = APIRouter() auth_handler = AuthHandler() @book_instance_router.get(\"/\") def get_book_instances(session=Depends(get_session)) -> list[BookInstanceReadFull]: return session.exec(select(BookInstance)).all() @book_instance_router.get(\"/{book_instance_id}\") def get_book_instance(book_instance_id: int, session=Depends(get_session)) -> BookInstanceReadFull: book_instance = session.get(BookInstance, book_instance_id) if not book_instance: raise HTTPException(status_code=404, detail=\"Book instance not found\") return book_instance @book_instance_router.post(\"/\") def create_book_instance(book_instance_data: BookInstanceBase, session=Depends(get_session), current=Depends(auth_handler.get_current_user)) -> BookInstance: book_instance = BookInstance.model_validate(book_instance_data) book_instance.owner_id = current.id session.add(book_instance) session.commit() session.refresh(book_instance) return book_instance @book_instance_router.patch(\"/{book_instance_id}\") def update_book_instance(book_instance_id: int, book_instance_data: BookInstanceBase, session=Depends(get_session), current=Depends(auth_handler.get_current_user)) -> BookInstance: book_instance = session.exec(select(BookInstance).where(BookInstance.id == book_instance_id)).first() if not book_instance: raise HTTPException(status_code=404, detail=\"Book not found\") if book_instance.owner_id != current.id: raise HTTPException(status_code=403, detail=\"Forbidden\") for key, value in book_instance_data.model_dump(exclude_unset=True).items(): setattr(book_instance, key, value) session.add(book_instance) session.commit() session.refresh(book_instance) return book_instance @book_instance_router.delete(\"/{book_instance_id}\") def delete_book_instance(book_instance_id: int, session=Depends(get_session), current=Depends(auth_handler.get_current_user)): book_instance = session.exec(select(BookInstance).where(BookInstance.id == book_instance_id)).first() if not book_instance: raise HTTPException(status_code=404, detail=\"Book not found\") if book_instance.owner_id != current.id: raise HTTPException(status_code=403, detail=\"Forbidden\") session.delete(book_instance) session.commit() return {\"ok\": True} book exchange from fastapi import APIRouter, HTTPException from sqlmodel import select from fastapi import Depends from models import BookExchange, BookExchangeBase, BookExchangeChangeStatus, BookExchangeReadFull from db.connection import get_session from auth.auth import AuthHandler from models import BookInstance book_exchange_router = APIRouter() auth_handler = AuthHandler() @book_exchange_router.get(\"/sender\") def get_book_exchanges(session=Depends(get_session), current=Depends(auth_handler.get_current_user)) -> list[BookExchangeReadFull]: return session.exec(select(BookExchange).where(BookExchange.sender_id==current.id)).all() @book_exchange_router.get(\"/receiver\") def get_book_exchanges(session=Depends(get_session), current=Depends(auth_handler.get_current_user)) -> list[BookExchangeReadFull]: return session.exec(select(BookExchange).where(BookExchange.receiver_id==current.id)).all() @book_exchange_router.get(\"/{book_exchange_id}\") def get_book_exchange(book_exchange_id: int, session=Depends(get_session)) -> BookExchangeReadFull: book_exchange = session.get(BookExchange, book_exchange_id) if not book_exchange: raise HTTPException(status_code=404, detail=\"Book exchange not found\") return book_exchange @book_exchange_router.post(\"/\") def create_book_exchange(book_exchange_data: BookExchangeBase, session=Depends(get_session), current=Depends(auth_handler.get_current_user)) -> BookExchange: book_exchange = BookExchange.model_validate(book_exchange_data) book_instance = session.get(BookInstance, book_exchange_data.book_instance_id) book_exchange.receiver_id = current.id book_exchange.sender_id = book_instance.owner_id session.add(book_exchange) session.commit() session.refresh(book_exchange) return book_exchange @book_exchange_router.patch(\"/{book_exchange_id}\") def update_book_exchange(book_exchange_id: int, book_exchange_data: BookExchangeChangeStatus, session=Depends(get_session), current=Depends(auth_handler.get_current_user)) -> BookExchange: book_exchange = session.exec(select(BookExchange).where(BookExchange.id == book_exchange_id)).first() if not book_exchange: raise HTTPException(status_code=404, detail=\"Book exchange not found\") if book_exchange.sender_id!=current.id: raise HTTPException(status_code=403, detail=\"Forbidden\") book_exchange.status = book_exchange_data.status session.add(book_exchange) session.commit() session.refresh(book_exchange) return book_exchange @book_exchange_router.delete(\"/{book_exchange_id}\") def delete_book_exchange(book_exchange_id: int, session=Depends(get_session), current=Depends(auth_handler.get_current_user)): book_exchange = session.exec(select(BookExchange).where(BookExchange.id == book_exchange_id)).first() if not book_exchange: raise HTTPException(status_code=404, detail=\"Book exchange not found\") if book_exchange.receiver_id!=current.id: raise HTTPException(status_code=403, detail=\"Forbidden\") session.delete(book_exchange) session.commit() return {\"ok\": True} author from fastapi import APIRouter, HTTPException from sqlmodel import select from fastapi import Depends from models import Author, AuthorBase, AuthorReadFull from db.connection import get_session author_router = APIRouter() @author_router.get(\"/\") def get_authors(session=Depends(get_session)) -> list[Author]: return session.exec(select(Author)).all() @author_router.get(\"/{author_id}\") def get_author(author_id: int, session=Depends(get_session)) -> AuthorReadFull: author = session.get(Author, author_id) if not author: raise HTTPException(status_code=404, detail=\"Author not found\") return author @author_router.post(\"/\") def create_author(author_data: AuthorBase, session=Depends(get_session)) -> Author: author = Author.model_validate(author_data) session.add(author) session.commit() session.refresh(author) return author @author_router.patch(\"/{author_id}\") def update_author(author_id: int, author_data: AuthorBase, session=Depends(get_session)) -> Author: author = session.exec(select(Author).where(Author.id == author_id)).first() if not author: raise HTTPException(status_code=404, detail=\"Author not found\") for key, value in author_data.model_dump(exclude_unset=True).items(): setattr(author, key, value) session.add(author) session.commit() session.refresh(author) return author @author_router.delete(\"/{author_id}\") def delete_author(author_id: int, session=Depends(get_session)): author = session.exec(select(Author).where(Author.id == author_id)).first() if not author: raise HTTPException(status_code=404, detail=\"Author not found\") session.delete(author) session.commit() return {\"ok\": True} DB connection from sqlmodel import SQLModel, Session, create_engine import os from dotenv import load_dotenv load_dotenv() db_url = os.getenv('DB_ADMIN') engine = create_engine(db_url, echo=True) session = Session(bind=engine) def init_db(): SQLModel.metadata.create_all(engine) def get_session(): with Session(engine) as session: yield session","title":"LR1"},{"location":"LR1/#models","text":"","title":"Models"},{"location":"LR1/#book-exchange","text":"class StatusType(Enum): notconsidered = \"not considered\" accepted = \"accepted\" rejected = \"rejected\" class BookExchangeBase(SQLModel): book_instance_id: Optional[int] = Field(default=None, foreign_key=\"bookinstance.id\") status: StatusType date_start: datetime.datetime date_end: datetime.datetime class BookExchange(BookExchangeBase, table=True): id: int = Field(default=None, primary_key=True) sender_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") receiver_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") sender: Optional[\"User\"] = Relationship( back_populates=\"sender_requests\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.sender_id]\"), ) receiver: Optional[\"User\"] = Relationship( back_populates=\"receiver_requests\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.receiver_id]\"), ) book_instance: Optional[\"BookInstance\"] = Relationship( back_populates=\"requests\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.book_instance_id]\"), ) class BookExchangeChangeStatus(SQLModel): status: StatusType class BookExchangeRead(BookExchangeBase): id: int sender_id: int receiver_id: int class BookExchangeReadFull(BookExchangeRead): sender: \"UserBase\" = None receiver: \"UserBase\" = None book_instance: \"BookInstanceWithBook\" = None","title":"book exchange"},{"location":"LR1/#book-instance","text":"class BookInstanceBase(SQLModel): book_id: Optional[int] = Field(default=None, foreign_key=\"book.id\") date: datetime.datetime publisher: str features: str class BookInstance(BookInstanceBase, table=True): id: int = Field(default=None, primary_key=True) owner_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") requests: Optional[List[\"BookExchange\"]] = Relationship( back_populates=\"book_instance\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.book_instance_id]\"), ) book: Optional[\"Book\"] = Relationship(back_populates=\"instances\") owner: Optional[\"User\"] = Relationship(back_populates=\"instances\") class BookInstanceRead(BookInstanceBase): id: int owner_id: int class BookInstanceWithBook(BookInstanceRead): book: \"BookRead\" = None class BookInstanceReadFull(BookInstanceWithBook): requests: list[\"BookExchangeRead\"] = [] owner: \"UserBase\" = None","title":"book instance"},{"location":"LR1/#author","text":"class AuthorBase(SQLModel): name: str bio: str class Author(AuthorBase, table=True): id: int = Field(default=None, primary_key=True) books: Optional[List[\"Book\"]] = Relationship(back_populates=\"author\") class AuthorRead(AuthorBase): id: int class AuthorReadFull(AuthorRead): books: list[\"BookRead\"] = []","title":"author"},{"location":"LR1/#book","text":"class BookBase(SQLModel): title: str description: str author_id: Optional[int] = Field(default=None, foreign_key=\"author.id\") class Book(BookBase, table=True): id: int = Field(default=None, primary_key=True) author: Optional[Author] = Relationship(back_populates=\"books\") owners: Optional[List[\"User\"]] = Relationship(back_populates=\"books\", link_model=BookInstance) instances: Optional[List[\"BookInstance\"]] = Relationship(back_populates=\"book\") class BookRead(BookBase): id: int class BookReadFull(BookRead): author: AuthorRead = None owners: list[\"UserBase\"] = [] instances: list[\"BookInstanceRead\"] = []","title":"book"},{"location":"LR1/#user","text":"class UserBase(SQLModel): id: int = Field(primary_key=True) username: str = Field(index=True) name: str about: str email: EmailStr = Field(unique=True, index=True, sa_type=AutoString) class User(UserBase, table=True): password: str = Field(max_length=256, min_length=6) created_at: datetime.datetime = datetime.datetime.now() books: Optional[List[\"Book\"]] = Relationship(back_populates=\"owners\", link_model=BookInstance) sender_requests: Optional[List[\"BookExchange\"]] = Relationship( back_populates=\"sender\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.sender_id]\"), ) receiver_requests: Optional[List[\"BookExchange\"]] = Relationship( back_populates=\"receiver\", sa_relationship_kwargs=dict(foreign_keys=\"[BookExchange.receiver_id]\"), ) instances: Optional[List[\"BookInstance\"]] = Relationship(back_populates=\"owner\") class UserReadFull(UserBase): sender_requests: list[\"BookExchangeRead\"] = [] receiver_requests: list[\"BookExchangeRead\"] = [] instances: list[\"BookInstanceWithBook\"] = [] class UserInput(SQLModel): name: str about: str username: str password: str = Field(max_length=256, min_length=6) password2: str email: EmailStr = Field(unique=True, index=True, sa_type=AutoString) @validator('password2') def password_match(cls, v, values, **kwargs): if 'password' in values and v != values['password']: raise ValueError('passwords don\\'t match') return v class UserLogin(SQLModel): username: str password: str class UserPassword(SQLModel): old_password: str new_password: str","title":"user"},{"location":"LR1/#endpointes","text":"","title":"Endpointes"},{"location":"LR1/#user_1","text":"from fastapi import APIRouter, HTTPException, Depends from starlette.status import HTTP_201_CREATED from auth.auth import AuthHandler from db.connection import get_session from models import UserInput, User, UserLogin, UserPassword, UserReadFull from sqlmodel import select user_router = APIRouter() auth_handler = AuthHandler() @user_router.post('/registration', status_code=201, description='Register new user') def register(user: UserInput, session=Depends(get_session)): users = session.exec(select(User)).all() if any(x.username == user.username for x in users): raise HTTPException(status_code=400, detail='Username is taken') if any(x.email == user.email for x in users): raise HTTPException(status_code=400, detail='Email is taken') hashed_pwd = auth_handler.get_password_hash(user.password) user = User(username=user.username, password=hashed_pwd, email=user.email, name=user.name, about=user.about) session.add(user) session.commit() return {\"status\": 201, \"message\": \"Created\"} @user_router.post('/login') def login(user: UserLogin, session=Depends(get_session)): user_found = session.exec(select(User).where(User.username == user.username)).first() if not user_found: raise HTTPException(status_code=401, detail='Invalid username and/or password') verified = auth_handler.verify_password(user.password, user_found.password) if not verified: raise HTTPException(status_code=401, detail='Invalid username and/or password') token = auth_handler.encode_token(user_found.username) return {'token': token} @user_router.get('/users/me') def get_current_user(user: User = Depends(auth_handler.get_current_user)) -> UserReadFull: return user @user_router.patch(\"/users/me/password\") def user_pwd(user_pwd: UserPassword, session=Depends(get_session), current=Depends(auth_handler.get_current_user)): found_user = session.get(User, current.id) if not found_user: raise HTTPException(status_code=404, detail=\"User not found\") verified = auth_handler.verify(user_pwd.old_password, found_user.password) if not verified: raise HTTPException(status_code=400, detail=\"Invalid old password\") hashed_pwd = auth_handler.get_password_hash(user_pwd.new_password) found_user.password = hashed_pwd session.add(found_user) session.commit() session.refresh(found_user) return {\"status\": 200, \"message\": \"password changed successfully\"} @user_router.get(\"/users\") def user_list(session=Depends(get_session)) -> list[User]: users = session.exec(select(User)).all() user_models = [user.model_dump(exclude={'password'}) for user in users] return user_models @user_router.get(\"/users/{user_id}\") def user_one(user_id: int, session=Depends(get_session)) -> UserReadFull: user = session.get(User, user_id) if not user: raise HTTPException(status_code=404, detail=\"User not found\") return user","title":"user"},{"location":"LR1/#book_1","text":"from fastapi import APIRouter, HTTPException from sqlmodel import select from fastapi import Depends from models import Book, BookBase, BookReadFull from db.connection import get_session book_router = APIRouter() @book_router.get(\"/\") def get_books(session=Depends(get_session)) -> list[BookReadFull] : return session.exec(select(Book)).all() @book_router.get(\"/{book_id}\") def get_book(book_id: int, session=Depends(get_session)) -> BookReadFull: book = session.get(Book, book_id) if not book: raise HTTPException(status_code=404, detail=\"Book not found\") return book @book_router.post(\"/\") def create_book(book_data: BookBase, session=Depends(get_session)) -> Book: book = Book.model_validate(book_data) session.add(book) session.commit() session.refresh(book) return book @book_router.patch(\"/{book_id}\") def update_book(book_id: int, book_data: BookBase, session=Depends(get_session)) -> Book: book = session.exec(select(Book).where(Book.id == book_id)).first() if not book: raise HTTPException(status_code=404, detail=\"Book not found\") for key, value in book_data.model_dump(exclude_unset=True).items(): setattr(book, key, value) session.add(book) session.commit() session.refresh(book) return book @book_router.delete(\"/{book_id}\") def delete_book(book_id: int, session=Depends(get_session)): book = session.exec(select(Book).where(Book.id == book_id)).first() if not book: raise HTTPException(status_code=404, detail=\"Book not found\") session.delete(book) session.commit() return {\"ok\": True}","title":"book"},{"location":"LR1/#book-instance_1","text":"from fastapi import APIRouter, HTTPException from sqlmodel import select from fastapi import Depends from models import BookInstance, BookInstanceBase, BookInstanceReadFull from db.connection import get_session from auth.auth import AuthHandler book_instance_router = APIRouter() auth_handler = AuthHandler() @book_instance_router.get(\"/\") def get_book_instances(session=Depends(get_session)) -> list[BookInstanceReadFull]: return session.exec(select(BookInstance)).all() @book_instance_router.get(\"/{book_instance_id}\") def get_book_instance(book_instance_id: int, session=Depends(get_session)) -> BookInstanceReadFull: book_instance = session.get(BookInstance, book_instance_id) if not book_instance: raise HTTPException(status_code=404, detail=\"Book instance not found\") return book_instance @book_instance_router.post(\"/\") def create_book_instance(book_instance_data: BookInstanceBase, session=Depends(get_session), current=Depends(auth_handler.get_current_user)) -> BookInstance: book_instance = BookInstance.model_validate(book_instance_data) book_instance.owner_id = current.id session.add(book_instance) session.commit() session.refresh(book_instance) return book_instance @book_instance_router.patch(\"/{book_instance_id}\") def update_book_instance(book_instance_id: int, book_instance_data: BookInstanceBase, session=Depends(get_session), current=Depends(auth_handler.get_current_user)) -> BookInstance: book_instance = session.exec(select(BookInstance).where(BookInstance.id == book_instance_id)).first() if not book_instance: raise HTTPException(status_code=404, detail=\"Book not found\") if book_instance.owner_id != current.id: raise HTTPException(status_code=403, detail=\"Forbidden\") for key, value in book_instance_data.model_dump(exclude_unset=True).items(): setattr(book_instance, key, value) session.add(book_instance) session.commit() session.refresh(book_instance) return book_instance @book_instance_router.delete(\"/{book_instance_id}\") def delete_book_instance(book_instance_id: int, session=Depends(get_session), current=Depends(auth_handler.get_current_user)): book_instance = session.exec(select(BookInstance).where(BookInstance.id == book_instance_id)).first() if not book_instance: raise HTTPException(status_code=404, detail=\"Book not found\") if book_instance.owner_id != current.id: raise HTTPException(status_code=403, detail=\"Forbidden\") session.delete(book_instance) session.commit() return {\"ok\": True}","title":"book instance"},{"location":"LR1/#book-exchange_1","text":"from fastapi import APIRouter, HTTPException from sqlmodel import select from fastapi import Depends from models import BookExchange, BookExchangeBase, BookExchangeChangeStatus, BookExchangeReadFull from db.connection import get_session from auth.auth import AuthHandler from models import BookInstance book_exchange_router = APIRouter() auth_handler = AuthHandler() @book_exchange_router.get(\"/sender\") def get_book_exchanges(session=Depends(get_session), current=Depends(auth_handler.get_current_user)) -> list[BookExchangeReadFull]: return session.exec(select(BookExchange).where(BookExchange.sender_id==current.id)).all() @book_exchange_router.get(\"/receiver\") def get_book_exchanges(session=Depends(get_session), current=Depends(auth_handler.get_current_user)) -> list[BookExchangeReadFull]: return session.exec(select(BookExchange).where(BookExchange.receiver_id==current.id)).all() @book_exchange_router.get(\"/{book_exchange_id}\") def get_book_exchange(book_exchange_id: int, session=Depends(get_session)) -> BookExchangeReadFull: book_exchange = session.get(BookExchange, book_exchange_id) if not book_exchange: raise HTTPException(status_code=404, detail=\"Book exchange not found\") return book_exchange @book_exchange_router.post(\"/\") def create_book_exchange(book_exchange_data: BookExchangeBase, session=Depends(get_session), current=Depends(auth_handler.get_current_user)) -> BookExchange: book_exchange = BookExchange.model_validate(book_exchange_data) book_instance = session.get(BookInstance, book_exchange_data.book_instance_id) book_exchange.receiver_id = current.id book_exchange.sender_id = book_instance.owner_id session.add(book_exchange) session.commit() session.refresh(book_exchange) return book_exchange @book_exchange_router.patch(\"/{book_exchange_id}\") def update_book_exchange(book_exchange_id: int, book_exchange_data: BookExchangeChangeStatus, session=Depends(get_session), current=Depends(auth_handler.get_current_user)) -> BookExchange: book_exchange = session.exec(select(BookExchange).where(BookExchange.id == book_exchange_id)).first() if not book_exchange: raise HTTPException(status_code=404, detail=\"Book exchange not found\") if book_exchange.sender_id!=current.id: raise HTTPException(status_code=403, detail=\"Forbidden\") book_exchange.status = book_exchange_data.status session.add(book_exchange) session.commit() session.refresh(book_exchange) return book_exchange @book_exchange_router.delete(\"/{book_exchange_id}\") def delete_book_exchange(book_exchange_id: int, session=Depends(get_session), current=Depends(auth_handler.get_current_user)): book_exchange = session.exec(select(BookExchange).where(BookExchange.id == book_exchange_id)).first() if not book_exchange: raise HTTPException(status_code=404, detail=\"Book exchange not found\") if book_exchange.receiver_id!=current.id: raise HTTPException(status_code=403, detail=\"Forbidden\") session.delete(book_exchange) session.commit() return {\"ok\": True}","title":"book exchange"},{"location":"LR1/#author_1","text":"from fastapi import APIRouter, HTTPException from sqlmodel import select from fastapi import Depends from models import Author, AuthorBase, AuthorReadFull from db.connection import get_session author_router = APIRouter() @author_router.get(\"/\") def get_authors(session=Depends(get_session)) -> list[Author]: return session.exec(select(Author)).all() @author_router.get(\"/{author_id}\") def get_author(author_id: int, session=Depends(get_session)) -> AuthorReadFull: author = session.get(Author, author_id) if not author: raise HTTPException(status_code=404, detail=\"Author not found\") return author @author_router.post(\"/\") def create_author(author_data: AuthorBase, session=Depends(get_session)) -> Author: author = Author.model_validate(author_data) session.add(author) session.commit() session.refresh(author) return author @author_router.patch(\"/{author_id}\") def update_author(author_id: int, author_data: AuthorBase, session=Depends(get_session)) -> Author: author = session.exec(select(Author).where(Author.id == author_id)).first() if not author: raise HTTPException(status_code=404, detail=\"Author not found\") for key, value in author_data.model_dump(exclude_unset=True).items(): setattr(author, key, value) session.add(author) session.commit() session.refresh(author) return author @author_router.delete(\"/{author_id}\") def delete_author(author_id: int, session=Depends(get_session)): author = session.exec(select(Author).where(Author.id == author_id)).first() if not author: raise HTTPException(status_code=404, detail=\"Author not found\") session.delete(author) session.commit() return {\"ok\": True}","title":"author"},{"location":"LR1/#db-connection","text":"from sqlmodel import SQLModel, Session, create_engine import os from dotenv import load_dotenv load_dotenv() db_url = os.getenv('DB_ADMIN') engine = create_engine(db_url, echo=True) session = Session(bind=engine) def init_db(): SQLModel.metadata.create_all(engine) def get_session(): with Session(engine) as session: yield session","title":"DB connection"},{"location":"LR2/","text":"Task 1 \u0417\u0430\u0434\u0430\u0447\u0430: \u041d\u0430\u043f\u0438\u0448\u0438\u0442\u0435 \u0442\u0440\u0438 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u043d\u0430 Python, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0449\u0438\u0435 \u043a\u0430\u0436\u0434\u044b\u0439 \u0438\u0437 \u043f\u043e\u0434\u0445\u043e\u0434\u043e\u0432: threading, multiprocessing \u0438 async. \u041a\u0430\u0436\u0434\u0430\u044f \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0440\u0435\u0448\u0430\u0442\u044c \u0441\u0447\u0438\u0442\u0430\u0442\u044c \u0441\u0443\u043c\u043c\u0443 \u0432\u0441\u0435\u0445 \u0447\u0438\u0441\u0435\u043b \u043e\u0442 1 \u0434\u043e 1000000. \u0420\u0430\u0437\u0434\u0435\u043b\u0438\u0442\u0435 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u043d\u0430 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u044b\u0445 \u0437\u0430\u0434\u0430\u0447 \u0434\u043b\u044f \u0443\u0441\u043a\u043e\u0440\u0435\u043d\u0438\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f. \u041f\u043e\u0434\u0440\u043e\u0431\u043d\u043e\u0441\u0442\u0438 \u0437\u0430\u0434\u0430\u043d\u0438\u044f: \u041d\u0430\u043f\u0438\u0448\u0438\u0442\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443 \u043d\u0430 Python \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u043f\u043e\u0434\u0445\u043e\u0434\u0430: threading, multiprocessing \u0438 async. \u041a\u0430\u0436\u0434\u0430\u044f \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u0444\u0443\u043d\u043a\u0446\u0438\u044e calculate_sum(), \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0431\u0443\u0434\u0435\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0442\u044c \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f. \u0414\u043b\u044f threading \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043c\u043e\u0434\u0443\u043b\u044c threading, \u0434\u043b\u044f multiprocessing - \u043c\u043e\u0434\u0443\u043b\u044c multiprocessing, \u0430 \u0434\u043b\u044f async - \u043a\u043b\u044e\u0447\u0435\u0432\u044b\u0435 \u0441\u043b\u043e\u0432\u0430 async/await \u0438 \u043c\u043e\u0434\u0443\u043b\u044c asyncio. \u041a\u0430\u0436\u0434\u0430\u044f \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0440\u0430\u0437\u0431\u0438\u0442\u044c \u0437\u0430\u0434\u0430\u0447\u0443 \u043d\u0430 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043f\u043e\u0434\u0437\u0430\u0434\u0430\u0447 \u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0442\u044c \u0438\u0445 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e. \u0417\u0430\u043c\u0435\u0440\u044c\u0442\u0435 \u0432\u0440\u0435\u043c\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u043a\u0430\u0436\u0434\u043e\u0439 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u0438 \u0441\u0440\u0430\u0432\u043d\u0438\u0442\u0435 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b. async import asyncio import time async def calculate_sum(start, end): return sum(range(start, end)) async def main(): start = 1 end = 1000000 n_tasks = 4 step = int(end / n_tasks) tasks = [] for i in range(n_tasks): step_start = i * step + start step_end = (i + 1) * step + start if i != n_tasks - 1 else end + 1 task = asyncio.create_task(calculate_sum(step_start, step_end)) tasks.append(task) results = await asyncio.gather(*tasks) total_sum = sum(results) print(\"Total sum:\", total_sum) if __name__ == '__main__': start_time = time.time() asyncio.run(main()) end_time = time.time() print(f\"Execution time: {end_time - start_time:.2f} seconds\") threading import threading import time def calculate_sum(start, end, result): total = sum(range(start, end)) result.append(total) def main(): start = 1 end = 1000000 n_threads = 4 results = [0] * n_threads step = int(end / n_threads) threads = [] for i in range(n_threads): step_start = i * step + start step_end = (i + 1) * step + start if i != n_threads - 1 else end + 1 thread = threading.Thread(target=calculate_sum, args=(step_start, step_end, results)) threads.append(thread) thread.start() for thread in threads: thread.join() total_sum = sum(results) print(f\"Total sum: {total_sum}\") if __name__ == '__main__': start_time = time.time() main() end_time = time.time() print(f\"Execution time: {end_time - start_time:.2f} seconds\") multiprocessing import multiprocessing import time def calculate_sum(start, end, result): total = sum(range(start, end)) result.put(total) def main(): start = 1 end = 1000000 n_processes = 4 result_queue = multiprocessing.Queue() step = int(end / n_processes) processes = [] for i in range(n_processes): step_start = i * step + start step_end = (i + 1) * step + start if i != n_processes - 1 else end + 1 process = multiprocessing.Process(target=calculate_sum, args=(step_start, step_end, result_queue)) processes.append(process) process.start() for process in processes: process.join() total_sum = sum(result_queue.get() for _ in range(n_processes)) print(f\"Total sum: {total_sum}\") if __name__ == '__main__': start_time = time.time() main() end_time = time.time() print(f\"Execution time: {end_time - start_time:.2f} seconds\") \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 Program Time async 0.03 threading 0.03 multiprocessing 0.19 Threading (0.03 \u0441\u0435\u043a\u0443\u043d\u0434\u044b) : \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u043f\u043e\u0442\u043e\u043a\u043e\u0432 (threading) \u0434\u043b\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0437\u0430\u0434\u0430\u0447\u0438 \u0431\u044b\u043b\u043e \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u0431\u044b\u0441\u0442\u0440\u044b\u043c. \u041f\u043e\u0442\u043e\u043a\u0438 \u0440\u0430\u0431\u043e\u0442\u0430\u044e\u0442 \u0432 \u0440\u0430\u043c\u043a\u0430\u0445 \u043e\u0434\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430, \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u0432\u0440\u0435\u043c\u044f \u0437\u0430\u0442\u0440\u0430\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0442\u043e\u043b\u044c\u043a\u043e \u043d\u0430 \u0441\u0430\u043c\u0443 \u0437\u0430\u0434\u0430\u0447\u0443. Multiprocessing (0.19 \u0441\u0435\u043a\u0443\u043d\u0434\u044b) : \u041c\u043d\u043e\u0433\u043e\u043f\u0440\u043e\u0446\u0435\u0441\u043e\u0440\u043d\u043e\u0441\u0442\u044c \u0437\u0430\u043d\u044f\u043b\u0430 \u0437\u043d\u0430\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u0431\u043e\u043b\u044c\u0448\u0435 \u0432\u0440\u0435\u043c\u0435\u043d\u0438. \u042d\u0442\u043e\u0442 \u043f\u043e\u0434\u0445\u043e\u0434 \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u0442 \u043a\u0430\u0436\u0434\u0443\u044e \u0437\u0430\u0434\u0430\u0447\u0443 \u0432 \u0441\u0432\u043e\u0435\u043c \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435, \u0447\u0442\u043e \u0438\u0434\u0435\u0430\u043b\u044c\u043d\u043e \u043f\u043e\u0434\u0445\u043e\u0434\u0438\u0442 \u0434\u043b\u044f CPU-\u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u044b\u0445 \u0437\u0430\u0434\u0430\u0447, \u043d\u043e \u0438\u0437-\u0437\u0430 \u043d\u0430\u043a\u043b\u0430\u0434\u043d\u044b\u0445 \u0440\u0430\u0441\u0445\u043e\u0434\u043e\u0432 \u043d\u0430 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432 \u0438 \u043e\u0431\u043c\u0435\u043d \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f\u043c\u0438 \u043c\u0435\u0436\u0434\u0443 \u043d\u0438\u043c\u0438 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043c\u0435\u043d\u0435\u0435 \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u044b\u043c \u0434\u043b\u044f \u043d\u0435\u0431\u043e\u043b\u044c\u0448\u0438\u0445 \u0438\u043b\u0438 \u0431\u044b\u0441\u0442\u0440\u044b\u0445 \u0437\u0430\u0434\u0430\u0447. Async (0.03 \u0441\u0435\u043a\u0443\u043d\u0434\u044b) : \u0410\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043f\u043e\u043a\u0430\u0437\u0430\u043b\u043e \u0432\u0440\u0435\u043c\u044f, \u0441\u043e\u043f\u043e\u0441\u0442\u0430\u0432\u0438\u043c\u043e\u0435 \u0441 threading, \u0447\u0442\u043e \u0434\u0435\u043b\u0430\u0435\u0442 \u0435\u0433\u043e \u043e\u0447\u0435\u043d\u044c \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u044b\u043c \u0434\u043b\u044f \u044d\u0442\u043e\u0439 \u0437\u0430\u0434\u0430\u0447\u0438. \u041e\u043d\u043e \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0442\u044c \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u0442\u0430\u043a\u0438\u0445 \u0437\u0430\u0434\u0430\u0447 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e \u0431\u0435\u0437 \u0437\u043d\u0430\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0445 \u043d\u0430\u043a\u043b\u0430\u0434\u043d\u044b\u0445 \u0440\u0430\u0441\u0445\u043e\u0434\u043e\u0432. Task 2 \u0417\u0430\u0434\u0430\u0447\u0430: \u041d\u0430\u043f\u0438\u0448\u0438\u0442\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443 \u043d\u0430 Python \u0434\u043b\u044f \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0430 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u0432\u0435\u0431-\u0441\u0442\u0440\u0430\u043d\u0438\u0446 \u0441 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0445 \u0432 \u0431\u0430\u0437\u0443 \u0434\u0430\u043d\u043d\u044b\u0445 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043f\u043e\u0434\u0445\u043e\u0434\u043e\u0432 threading, multiprocessing \u0438 async. \u041a\u0430\u0436\u0434\u0430\u044f \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u043f\u0430\u0440\u0441\u0438\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u0441 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u0432\u0435\u0431-\u0441\u0430\u0439\u0442\u043e\u0432, \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u0442\u044c \u0438\u0445 \u0432 \u0431\u0430\u0437\u0443 \u0434\u0430\u043d\u043d\u044b\u0445. \u041f\u043e\u0434\u0440\u043e\u0431\u043d\u043e\u0441\u0442\u0438 \u0437\u0430\u0434\u0430\u043d\u0438\u044f: \u041d\u0430\u043f\u0438\u0448\u0438\u0442\u0435 \u0442\u0440\u0438 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u043d\u0430 Python, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0449\u0438\u0435 \u043a\u0430\u0436\u0434\u044b\u0439 \u0438\u0437 \u043f\u043e\u0434\u0445\u043e\u0434\u043e\u0432: threading, multiprocessing \u0438 async. \u041a\u0430\u0436\u0434\u0430\u044f \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u0444\u0443\u043d\u043a\u0446\u0438\u044e parse_and_save(url), \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0431\u0443\u0434\u0435\u0442 \u0437\u0430\u0433\u0440\u0443\u0436\u0430\u0442\u044c HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443 \u043f\u043e \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u043c\u0443 URL, \u043f\u0430\u0440\u0441\u0438\u0442\u044c \u0435\u0435, \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u0442\u044c \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b \u0432 \u0431\u0430\u0437\u0443 \u0434\u0430\u043d\u043d\u044b\u0445 \u0438 \u0432\u044b\u0432\u043e\u0434\u0438\u0442\u044c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043d\u0430 \u044d\u043a\u0440\u0430\u043d. \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0431\u0430\u0437\u0443 \u0434\u0430\u043d\u043d\u044b\u0445 \u0438\u0437 \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b \u043d\u043e\u043c\u0435\u0440 1 \u0434\u043b\u044f \u0437\u0430\u043f\u043e\u043b\u0435\u043d\u043d\u0438\u044f \u0435\u0435 \u0434\u0430\u043d\u043d\u044b\u043c\u0438. \u0415\u0441\u043b\u0438 \u0412\u044b \u043d\u0435 \u043f\u043e\u043d\u0438\u043c\u0430\u0435\u0442\u0435, \u043a\u0430\u043a\u0438\u0435 \u0442\u0430\u0431\u043b\u0438\u0446\u044b \u0438 \u043e\u0442\u043a\u0443\u0434\u0430 \u0412\u044b \u043c\u043e\u0433\u043b\u0438 \u0431\u044b \u0437\u0430\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0430, \u043d\u0430\u043f\u0438\u0448\u0438\u0442\u0435 \u043f\u0440\u0435\u043f\u043e\u0434\u0430\u0432\u0430\u0442\u0435\u043b\u044e \u0432 \u043e\u0431\u0449\u0435\u043c \u0447\u0430\u0442\u0435 \u043f\u043e\u0442\u043e\u043a\u0430. \u0414\u043b\u044f threading \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043c\u043e\u0434\u0443\u043b\u044c threading, \u0434\u043b\u044f multiprocessing - \u043c\u043e\u0434\u0443\u043b\u044c multiprocessing, \u0430 \u0434\u043b\u044f async - \u043a\u043b\u044e\u0447\u0435\u0432\u044b\u0435 \u0441\u043b\u043e\u0432\u0430 async/await \u0438 \u043c\u043e\u0434\u0443\u043b\u044c aiohttp \u0434\u043b\u044f \u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u044b\u0445 \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432. \u0421\u043e\u0437\u0434\u0430\u0439\u0442\u0435 \u0441\u043f\u0438\u0441\u043e\u043a \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 URL-\u0430\u0434\u0440\u0435\u0441\u043e\u0432 \u0432\u0435\u0431-\u0441\u0442\u0440\u0430\u043d\u0438\u0446 \u0434\u043b\u044f \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0430 \u0438 \u0440\u0430\u0437\u0434\u0435\u043b\u0438\u0442\u0435 \u0435\u0433\u043e \u043d\u0430 \u0440\u0430\u0432\u043d\u044b\u0435 \u0447\u0430\u0441\u0442\u0438 \u0434\u043b\u044f \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0430. \u0417\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u0435 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0441\u0438\u043d\u0433 \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0439 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0432 \u0431\u0430\u0437\u0443 \u0434\u0430\u043d\u043d\u044b\u0445. \u0417\u0430\u043c\u0435\u0440\u044c\u0442\u0435 \u0432\u0440\u0435\u043c\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u043a\u0430\u0436\u0434\u043e\u0439 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u0438 \u0441\u0440\u0430\u0432\u043d\u0438\u0442\u0435 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b. async import asyncio import time import config import aiohttp from bs4 import BeautifulSoup from connection import DataBaseConnection async def get_bio(session, url): async with session.get(url) as response: html = await response.text() soup = BeautifulSoup(html, 'html.parser') text = soup.find('div', class_='xZmPc') bio_container = text.find('div') if bio_container.em and bio_container.em.text: return bio_container.em.text if bio_container.text: return bio_container.text async def parse_and_save(url, db_conn): try: async with aiohttp.ClientSession(connector=aiohttp.TCPConnector(ssl=False)) as session: async with session.get(url) as response: html = await response.text() soup = BeautifulSoup(html, 'html.parser') tasks = soup.find_all('div', class_='CHPy6') for task in tasks: name = task.find('div', class_='dbENL').text + ' ' + task.find('div', class_='p1Gbz').text bio = await get_bio(session, 'https://www.culture.ru' + task.a['href']) with db_conn.cursor() as cursor: cursor.execute(DataBaseConnection.INSERT_SQL, (name, bio)) db_conn.commit() except Exception as e: print(\"Error:\", e) async def process_url_list(url_list, conn): tasks = [] for url in url_list: task = asyncio.create_task(parse_and_save(url, conn)) tasks.append(task) await asyncio.gather(*tasks) async def main(): urls = config.URLS num_threads = config.NUM_THREADS chunk_size = len(urls) // num_threads url_chunks = [urls[i:i + chunk_size] for i in range(0, len(urls), chunk_size)] db_conn = DataBaseConnection.connect_to_database() await asyncio.gather(*(process_url_list(chunk, db_conn) for chunk in url_chunks)) db_conn.close() if __name__ == '__main__': start_time = time.time() asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy()) asyncio.run(main()) end_time = time.time() print(f\"Execution time: {end_time - start_time:.2f} seconds\") # 20.71 threading import threading import time import config from connection import DataBaseConnection import requests from bs4 import BeautifulSoup def get_bio(url): response = requests.get(url) html = response.text soup = BeautifulSoup(html, 'html.parser') text = soup.find('div', class_='xZmPc') bio_container = text.find('div') if bio_container.em and bio_container.em.text: return bio_container.em.text if bio_container.text: return bio_container.text def parse_and_save(url, db_conn): try: response = requests.get(url) html = response.text soup = BeautifulSoup(html, 'html.parser') tasks = soup.find_all('div', class_='CHPy6') for task in tasks: name = task.find('div', class_='dbENL').text + ' ' + task.find('div', class_='p1Gbz').text bio = get_bio('https://www.culture.ru' + task.a['href']) with db_conn.cursor() as cursor: cursor.execute(DataBaseConnection.INSERT_SQL, (name, bio)) db_conn.commit() except Exception as e: print(\"Error:\", e) def process_url_list(url_list, db_conn): for url in url_list: parse_and_save(url, db_conn) def main(): urls = config.URLS num_threads = config.NUM_THREADS chunk_size = len(urls) // num_threads url_chunks = [urls[i:i + chunk_size] for i in range(0, len(urls), chunk_size)] db_conn = DataBaseConnection.connect_to_database() threads = [] for chunk in url_chunks: thread = threading.Thread(target=process_url_list, args=(chunk, db_conn)) threads.append(thread) thread.start() for thread in threads: thread.join() db_conn.close() if __name__ == '__main__': start_time = time.time() main() end_time = time.time() print(f\"Execution time: {end_time - start_time:.2f} seconds\") # 33.34 multiprocessing import multiprocessing import time import config from connection import DataBaseConnection import requests from bs4 import BeautifulSoup def get_bio(url): response = requests.get(url) html = response.text soup = BeautifulSoup(html, 'html.parser') text = soup.find('div', class_='xZmPc') bio_container = text.find('div') if bio_container.em and bio_container.em.text: return bio_container.em.text if bio_container.text: return bio_container.text def parse_and_save(url, db_conn): try: response = requests.get(url) html = response.text soup = BeautifulSoup(html, 'html.parser') tasks = soup.find_all('div', class_='CHPy6') for task in tasks: name = task.find('div', class_='dbENL').text + ' ' + task.find('div', class_='p1Gbz').text bio = get_bio('https://www.culture.ru' + task.a['href']) with db_conn.cursor() as cursor: cursor.execute(DataBaseConnection.INSERT_SQL, (name, bio)) db_conn.commit() except Exception as e: print(\"Error:\", e) def process_url_list(url_list): db_conn = DataBaseConnection.connect_to_database() for url in url_list: parse_and_save(url, db_conn) db_conn.close() def main(): urls = config.URLS num_threads = config.NUM_THREADS chunk_size = len(urls) // num_threads url_chunks = [urls[i:i + chunk_size] for i in range(0, len(urls), chunk_size)] processes = [] for chunk in url_chunks: process = multiprocessing.Process(target=process_url_list, args=(chunk,)) process.start() processes.append(process) for process in processes: process.join() if __name__ == '__main__': start_time = time.time() main() end_time = time.time() print(f\"Execution time: {end_time - start_time:.2f} seconds\") # 36.76 \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 Program Time async 20.71 threading 33.34 multiprocessing 36.76 \u0410\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 (async) \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043d\u0430\u0438\u0431\u043e\u043b\u0435\u0435 \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u044b\u043c \u043f\u043e\u0434\u0445\u043e\u0434\u043e\u043c \u0434\u043b\u044f \u0437\u0430\u0434\u0430\u0447\u0438 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0430 \u0432\u0435\u0431-\u0441\u0442\u0440\u0430\u043d\u0438\u0446 \u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0434\u0430\u043d\u043d\u044b\u0445 \u0432 \u0431\u0430\u0437\u0443 \u0434\u0430\u043d\u043d\u044b\u0445, \u043e\u0441\u043e\u0431\u0435\u043d\u043d\u043e \u043a\u043e\u0433\u0434\u0430 \u0437\u0430\u0434\u0430\u0447\u0430 \u0432\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u043c\u043d\u043e\u0433\u043e I/O \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0439, \u0442\u0430\u043a\u0438\u0445 \u043a\u0430\u043a \u0437\u0430\u043f\u0440\u043e\u0441\u044b \u043a \u0432\u0435\u0431-\u0441\u0435\u0440\u0432\u0435\u0440\u0430\u043c. \u041f\u043e\u0434\u0445\u043e\u0434 threading \u0442\u0430\u043a\u0436\u0435 \u043f\u043e\u043a\u0430\u0437\u0430\u043b \u0445\u043e\u0440\u043e\u0448\u0438\u0435 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0438 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043f\u0440\u0435\u0434\u043f\u043e\u0447\u0442\u0438\u0442\u0435\u043b\u0435\u043d \u0434\u043b\u044f \u043f\u0440\u043e\u0441\u0442\u044b\u0445 \u0437\u0430\u0434\u0430\u0447 \u0438\u043b\u0438 \u043a\u043e\u0433\u0434\u0430 \u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043d\u0435 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u043e. Multiprocessing, \u0445\u043e\u0442\u044f \u0438 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043f\u043e\u043b\u0435\u0437\u043d\u044b\u043c \u0434\u043b\u044f CPU-\u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u044b\u0445 \u0437\u0430\u0434\u0430\u0447, \u043e\u043a\u0430\u0437\u0430\u043b\u0441\u044f \u043c\u0435\u043d\u0435\u0435 \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u044b\u043c \u0434\u043b\u044f \u0434\u0430\u043d\u043d\u043e\u0439 \u0437\u0430\u0434\u0430\u0447\u0438 \u0438\u0437-\u0437\u0430 \u0431\u043e\u043b\u044c\u0448\u0438\u0445 \u043d\u0430\u043a\u043b\u0430\u0434\u043d\u044b\u0445 \u0440\u0430\u0441\u0445\u043e\u0434\u043e\u0432 \u043d\u0430 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430\u043c\u0438.","title":"LR2"},{"location":"LR2/#task-1","text":"\u0417\u0430\u0434\u0430\u0447\u0430: \u041d\u0430\u043f\u0438\u0448\u0438\u0442\u0435 \u0442\u0440\u0438 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u043d\u0430 Python, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0449\u0438\u0435 \u043a\u0430\u0436\u0434\u044b\u0439 \u0438\u0437 \u043f\u043e\u0434\u0445\u043e\u0434\u043e\u0432: threading, multiprocessing \u0438 async. \u041a\u0430\u0436\u0434\u0430\u044f \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0440\u0435\u0448\u0430\u0442\u044c \u0441\u0447\u0438\u0442\u0430\u0442\u044c \u0441\u0443\u043c\u043c\u0443 \u0432\u0441\u0435\u0445 \u0447\u0438\u0441\u0435\u043b \u043e\u0442 1 \u0434\u043e 1000000. \u0420\u0430\u0437\u0434\u0435\u043b\u0438\u0442\u0435 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u043d\u0430 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u044b\u0445 \u0437\u0430\u0434\u0430\u0447 \u0434\u043b\u044f \u0443\u0441\u043a\u043e\u0440\u0435\u043d\u0438\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f. \u041f\u043e\u0434\u0440\u043e\u0431\u043d\u043e\u0441\u0442\u0438 \u0437\u0430\u0434\u0430\u043d\u0438\u044f: \u041d\u0430\u043f\u0438\u0448\u0438\u0442\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443 \u043d\u0430 Python \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u043f\u043e\u0434\u0445\u043e\u0434\u0430: threading, multiprocessing \u0438 async. \u041a\u0430\u0436\u0434\u0430\u044f \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u0444\u0443\u043d\u043a\u0446\u0438\u044e calculate_sum(), \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0431\u0443\u0434\u0435\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0442\u044c \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f. \u0414\u043b\u044f threading \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043c\u043e\u0434\u0443\u043b\u044c threading, \u0434\u043b\u044f multiprocessing - \u043c\u043e\u0434\u0443\u043b\u044c multiprocessing, \u0430 \u0434\u043b\u044f async - \u043a\u043b\u044e\u0447\u0435\u0432\u044b\u0435 \u0441\u043b\u043e\u0432\u0430 async/await \u0438 \u043c\u043e\u0434\u0443\u043b\u044c asyncio. \u041a\u0430\u0436\u0434\u0430\u044f \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0440\u0430\u0437\u0431\u0438\u0442\u044c \u0437\u0430\u0434\u0430\u0447\u0443 \u043d\u0430 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043f\u043e\u0434\u0437\u0430\u0434\u0430\u0447 \u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0442\u044c \u0438\u0445 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e. \u0417\u0430\u043c\u0435\u0440\u044c\u0442\u0435 \u0432\u0440\u0435\u043c\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u043a\u0430\u0436\u0434\u043e\u0439 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u0438 \u0441\u0440\u0430\u0432\u043d\u0438\u0442\u0435 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b.","title":"Task 1"},{"location":"LR2/#async","text":"import asyncio import time async def calculate_sum(start, end): return sum(range(start, end)) async def main(): start = 1 end = 1000000 n_tasks = 4 step = int(end / n_tasks) tasks = [] for i in range(n_tasks): step_start = i * step + start step_end = (i + 1) * step + start if i != n_tasks - 1 else end + 1 task = asyncio.create_task(calculate_sum(step_start, step_end)) tasks.append(task) results = await asyncio.gather(*tasks) total_sum = sum(results) print(\"Total sum:\", total_sum) if __name__ == '__main__': start_time = time.time() asyncio.run(main()) end_time = time.time() print(f\"Execution time: {end_time - start_time:.2f} seconds\")","title":"async"},{"location":"LR2/#threading","text":"import threading import time def calculate_sum(start, end, result): total = sum(range(start, end)) result.append(total) def main(): start = 1 end = 1000000 n_threads = 4 results = [0] * n_threads step = int(end / n_threads) threads = [] for i in range(n_threads): step_start = i * step + start step_end = (i + 1) * step + start if i != n_threads - 1 else end + 1 thread = threading.Thread(target=calculate_sum, args=(step_start, step_end, results)) threads.append(thread) thread.start() for thread in threads: thread.join() total_sum = sum(results) print(f\"Total sum: {total_sum}\") if __name__ == '__main__': start_time = time.time() main() end_time = time.time() print(f\"Execution time: {end_time - start_time:.2f} seconds\")","title":"threading"},{"location":"LR2/#multiprocessing","text":"import multiprocessing import time def calculate_sum(start, end, result): total = sum(range(start, end)) result.put(total) def main(): start = 1 end = 1000000 n_processes = 4 result_queue = multiprocessing.Queue() step = int(end / n_processes) processes = [] for i in range(n_processes): step_start = i * step + start step_end = (i + 1) * step + start if i != n_processes - 1 else end + 1 process = multiprocessing.Process(target=calculate_sum, args=(step_start, step_end, result_queue)) processes.append(process) process.start() for process in processes: process.join() total_sum = sum(result_queue.get() for _ in range(n_processes)) print(f\"Total sum: {total_sum}\") if __name__ == '__main__': start_time = time.time() main() end_time = time.time() print(f\"Execution time: {end_time - start_time:.2f} seconds\")","title":"multiprocessing"},{"location":"LR2/#_1","text":"Program Time async 0.03 threading 0.03 multiprocessing 0.19 Threading (0.03 \u0441\u0435\u043a\u0443\u043d\u0434\u044b) : \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u043f\u043e\u0442\u043e\u043a\u043e\u0432 (threading) \u0434\u043b\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0437\u0430\u0434\u0430\u0447\u0438 \u0431\u044b\u043b\u043e \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u0431\u044b\u0441\u0442\u0440\u044b\u043c. \u041f\u043e\u0442\u043e\u043a\u0438 \u0440\u0430\u0431\u043e\u0442\u0430\u044e\u0442 \u0432 \u0440\u0430\u043c\u043a\u0430\u0445 \u043e\u0434\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430, \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u0432\u0440\u0435\u043c\u044f \u0437\u0430\u0442\u0440\u0430\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u0442\u043e\u043b\u044c\u043a\u043e \u043d\u0430 \u0441\u0430\u043c\u0443 \u0437\u0430\u0434\u0430\u0447\u0443. Multiprocessing (0.19 \u0441\u0435\u043a\u0443\u043d\u0434\u044b) : \u041c\u043d\u043e\u0433\u043e\u043f\u0440\u043e\u0446\u0435\u0441\u043e\u0440\u043d\u043e\u0441\u0442\u044c \u0437\u0430\u043d\u044f\u043b\u0430 \u0437\u043d\u0430\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u0431\u043e\u043b\u044c\u0448\u0435 \u0432\u0440\u0435\u043c\u0435\u043d\u0438. \u042d\u0442\u043e\u0442 \u043f\u043e\u0434\u0445\u043e\u0434 \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u0442 \u043a\u0430\u0436\u0434\u0443\u044e \u0437\u0430\u0434\u0430\u0447\u0443 \u0432 \u0441\u0432\u043e\u0435\u043c \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435, \u0447\u0442\u043e \u0438\u0434\u0435\u0430\u043b\u044c\u043d\u043e \u043f\u043e\u0434\u0445\u043e\u0434\u0438\u0442 \u0434\u043b\u044f CPU-\u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u044b\u0445 \u0437\u0430\u0434\u0430\u0447, \u043d\u043e \u0438\u0437-\u0437\u0430 \u043d\u0430\u043a\u043b\u0430\u0434\u043d\u044b\u0445 \u0440\u0430\u0441\u0445\u043e\u0434\u043e\u0432 \u043d\u0430 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432 \u0438 \u043e\u0431\u043c\u0435\u043d \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f\u043c\u0438 \u043c\u0435\u0436\u0434\u0443 \u043d\u0438\u043c\u0438 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043c\u0435\u043d\u0435\u0435 \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u044b\u043c \u0434\u043b\u044f \u043d\u0435\u0431\u043e\u043b\u044c\u0448\u0438\u0445 \u0438\u043b\u0438 \u0431\u044b\u0441\u0442\u0440\u044b\u0445 \u0437\u0430\u0434\u0430\u0447. Async (0.03 \u0441\u0435\u043a\u0443\u043d\u0434\u044b) : \u0410\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043f\u043e\u043a\u0430\u0437\u0430\u043b\u043e \u0432\u0440\u0435\u043c\u044f, \u0441\u043e\u043f\u043e\u0441\u0442\u0430\u0432\u0438\u043c\u043e\u0435 \u0441 threading, \u0447\u0442\u043e \u0434\u0435\u043b\u0430\u0435\u0442 \u0435\u0433\u043e \u043e\u0447\u0435\u043d\u044c \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u044b\u043c \u0434\u043b\u044f \u044d\u0442\u043e\u0439 \u0437\u0430\u0434\u0430\u0447\u0438. \u041e\u043d\u043e \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0442\u044c \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u0442\u0430\u043a\u0438\u0445 \u0437\u0430\u0434\u0430\u0447 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e \u0431\u0435\u0437 \u0437\u043d\u0430\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0445 \u043d\u0430\u043a\u043b\u0430\u0434\u043d\u044b\u0445 \u0440\u0430\u0441\u0445\u043e\u0434\u043e\u0432.","title":"\u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442"},{"location":"LR2/#task-2","text":"\u0417\u0430\u0434\u0430\u0447\u0430: \u041d\u0430\u043f\u0438\u0448\u0438\u0442\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443 \u043d\u0430 Python \u0434\u043b\u044f \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0430 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u0432\u0435\u0431-\u0441\u0442\u0440\u0430\u043d\u0438\u0446 \u0441 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0445 \u0432 \u0431\u0430\u0437\u0443 \u0434\u0430\u043d\u043d\u044b\u0445 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u043f\u043e\u0434\u0445\u043e\u0434\u043e\u0432 threading, multiprocessing \u0438 async. \u041a\u0430\u0436\u0434\u0430\u044f \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u043f\u0430\u0440\u0441\u0438\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u0441 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u0432\u0435\u0431-\u0441\u0430\u0439\u0442\u043e\u0432, \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u0442\u044c \u0438\u0445 \u0432 \u0431\u0430\u0437\u0443 \u0434\u0430\u043d\u043d\u044b\u0445. \u041f\u043e\u0434\u0440\u043e\u0431\u043d\u043e\u0441\u0442\u0438 \u0437\u0430\u0434\u0430\u043d\u0438\u044f: \u041d\u0430\u043f\u0438\u0448\u0438\u0442\u0435 \u0442\u0440\u0438 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u043d\u0430 Python, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0449\u0438\u0435 \u043a\u0430\u0436\u0434\u044b\u0439 \u0438\u0437 \u043f\u043e\u0434\u0445\u043e\u0434\u043e\u0432: threading, multiprocessing \u0438 async. \u041a\u0430\u0436\u0434\u0430\u044f \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u0444\u0443\u043d\u043a\u0446\u0438\u044e parse_and_save(url), \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0431\u0443\u0434\u0435\u0442 \u0437\u0430\u0433\u0440\u0443\u0436\u0430\u0442\u044c HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443 \u043f\u043e \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u043c\u0443 URL, \u043f\u0430\u0440\u0441\u0438\u0442\u044c \u0435\u0435, \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u0442\u044c \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b \u0432 \u0431\u0430\u0437\u0443 \u0434\u0430\u043d\u043d\u044b\u0445 \u0438 \u0432\u044b\u0432\u043e\u0434\u0438\u0442\u044c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043d\u0430 \u044d\u043a\u0440\u0430\u043d. \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u0431\u0430\u0437\u0443 \u0434\u0430\u043d\u043d\u044b\u0445 \u0438\u0437 \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b \u043d\u043e\u043c\u0435\u0440 1 \u0434\u043b\u044f \u0437\u0430\u043f\u043e\u043b\u0435\u043d\u043d\u0438\u044f \u0435\u0435 \u0434\u0430\u043d\u043d\u044b\u043c\u0438. \u0415\u0441\u043b\u0438 \u0412\u044b \u043d\u0435 \u043f\u043e\u043d\u0438\u043c\u0430\u0435\u0442\u0435, \u043a\u0430\u043a\u0438\u0435 \u0442\u0430\u0431\u043b\u0438\u0446\u044b \u0438 \u043e\u0442\u043a\u0443\u0434\u0430 \u0412\u044b \u043c\u043e\u0433\u043b\u0438 \u0431\u044b \u0437\u0430\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0430, \u043d\u0430\u043f\u0438\u0448\u0438\u0442\u0435 \u043f\u0440\u0435\u043f\u043e\u0434\u0430\u0432\u0430\u0442\u0435\u043b\u044e \u0432 \u043e\u0431\u0449\u0435\u043c \u0447\u0430\u0442\u0435 \u043f\u043e\u0442\u043e\u043a\u0430. \u0414\u043b\u044f threading \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 \u043c\u043e\u0434\u0443\u043b\u044c threading, \u0434\u043b\u044f multiprocessing - \u043c\u043e\u0434\u0443\u043b\u044c multiprocessing, \u0430 \u0434\u043b\u044f async - \u043a\u043b\u044e\u0447\u0435\u0432\u044b\u0435 \u0441\u043b\u043e\u0432\u0430 async/await \u0438 \u043c\u043e\u0434\u0443\u043b\u044c aiohttp \u0434\u043b\u044f \u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u044b\u0445 \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432. \u0421\u043e\u0437\u0434\u0430\u0439\u0442\u0435 \u0441\u043f\u0438\u0441\u043e\u043a \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 URL-\u0430\u0434\u0440\u0435\u0441\u043e\u0432 \u0432\u0435\u0431-\u0441\u0442\u0440\u0430\u043d\u0438\u0446 \u0434\u043b\u044f \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0430 \u0438 \u0440\u0430\u0437\u0434\u0435\u043b\u0438\u0442\u0435 \u0435\u0433\u043e \u043d\u0430 \u0440\u0430\u0432\u043d\u044b\u0435 \u0447\u0430\u0441\u0442\u0438 \u0434\u043b\u044f \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0430. \u0417\u0430\u043f\u0443\u0441\u0442\u0438\u0442\u0435 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0441\u0438\u043d\u0433 \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0439 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0432 \u0431\u0430\u0437\u0443 \u0434\u0430\u043d\u043d\u044b\u0445. \u0417\u0430\u043c\u0435\u0440\u044c\u0442\u0435 \u0432\u0440\u0435\u043c\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u043a\u0430\u0436\u0434\u043e\u0439 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u0438 \u0441\u0440\u0430\u0432\u043d\u0438\u0442\u0435 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b.","title":"Task 2"},{"location":"LR2/#async_1","text":"import asyncio import time import config import aiohttp from bs4 import BeautifulSoup from connection import DataBaseConnection async def get_bio(session, url): async with session.get(url) as response: html = await response.text() soup = BeautifulSoup(html, 'html.parser') text = soup.find('div', class_='xZmPc') bio_container = text.find('div') if bio_container.em and bio_container.em.text: return bio_container.em.text if bio_container.text: return bio_container.text async def parse_and_save(url, db_conn): try: async with aiohttp.ClientSession(connector=aiohttp.TCPConnector(ssl=False)) as session: async with session.get(url) as response: html = await response.text() soup = BeautifulSoup(html, 'html.parser') tasks = soup.find_all('div', class_='CHPy6') for task in tasks: name = task.find('div', class_='dbENL').text + ' ' + task.find('div', class_='p1Gbz').text bio = await get_bio(session, 'https://www.culture.ru' + task.a['href']) with db_conn.cursor() as cursor: cursor.execute(DataBaseConnection.INSERT_SQL, (name, bio)) db_conn.commit() except Exception as e: print(\"Error:\", e) async def process_url_list(url_list, conn): tasks = [] for url in url_list: task = asyncio.create_task(parse_and_save(url, conn)) tasks.append(task) await asyncio.gather(*tasks) async def main(): urls = config.URLS num_threads = config.NUM_THREADS chunk_size = len(urls) // num_threads url_chunks = [urls[i:i + chunk_size] for i in range(0, len(urls), chunk_size)] db_conn = DataBaseConnection.connect_to_database() await asyncio.gather(*(process_url_list(chunk, db_conn) for chunk in url_chunks)) db_conn.close() if __name__ == '__main__': start_time = time.time() asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy()) asyncio.run(main()) end_time = time.time() print(f\"Execution time: {end_time - start_time:.2f} seconds\") # 20.71","title":"async"},{"location":"LR2/#threading_1","text":"import threading import time import config from connection import DataBaseConnection import requests from bs4 import BeautifulSoup def get_bio(url): response = requests.get(url) html = response.text soup = BeautifulSoup(html, 'html.parser') text = soup.find('div', class_='xZmPc') bio_container = text.find('div') if bio_container.em and bio_container.em.text: return bio_container.em.text if bio_container.text: return bio_container.text def parse_and_save(url, db_conn): try: response = requests.get(url) html = response.text soup = BeautifulSoup(html, 'html.parser') tasks = soup.find_all('div', class_='CHPy6') for task in tasks: name = task.find('div', class_='dbENL').text + ' ' + task.find('div', class_='p1Gbz').text bio = get_bio('https://www.culture.ru' + task.a['href']) with db_conn.cursor() as cursor: cursor.execute(DataBaseConnection.INSERT_SQL, (name, bio)) db_conn.commit() except Exception as e: print(\"Error:\", e) def process_url_list(url_list, db_conn): for url in url_list: parse_and_save(url, db_conn) def main(): urls = config.URLS num_threads = config.NUM_THREADS chunk_size = len(urls) // num_threads url_chunks = [urls[i:i + chunk_size] for i in range(0, len(urls), chunk_size)] db_conn = DataBaseConnection.connect_to_database() threads = [] for chunk in url_chunks: thread = threading.Thread(target=process_url_list, args=(chunk, db_conn)) threads.append(thread) thread.start() for thread in threads: thread.join() db_conn.close() if __name__ == '__main__': start_time = time.time() main() end_time = time.time() print(f\"Execution time: {end_time - start_time:.2f} seconds\") # 33.34","title":"threading"},{"location":"LR2/#multiprocessing_1","text":"import multiprocessing import time import config from connection import DataBaseConnection import requests from bs4 import BeautifulSoup def get_bio(url): response = requests.get(url) html = response.text soup = BeautifulSoup(html, 'html.parser') text = soup.find('div', class_='xZmPc') bio_container = text.find('div') if bio_container.em and bio_container.em.text: return bio_container.em.text if bio_container.text: return bio_container.text def parse_and_save(url, db_conn): try: response = requests.get(url) html = response.text soup = BeautifulSoup(html, 'html.parser') tasks = soup.find_all('div', class_='CHPy6') for task in tasks: name = task.find('div', class_='dbENL').text + ' ' + task.find('div', class_='p1Gbz').text bio = get_bio('https://www.culture.ru' + task.a['href']) with db_conn.cursor() as cursor: cursor.execute(DataBaseConnection.INSERT_SQL, (name, bio)) db_conn.commit() except Exception as e: print(\"Error:\", e) def process_url_list(url_list): db_conn = DataBaseConnection.connect_to_database() for url in url_list: parse_and_save(url, db_conn) db_conn.close() def main(): urls = config.URLS num_threads = config.NUM_THREADS chunk_size = len(urls) // num_threads url_chunks = [urls[i:i + chunk_size] for i in range(0, len(urls), chunk_size)] processes = [] for chunk in url_chunks: process = multiprocessing.Process(target=process_url_list, args=(chunk,)) process.start() processes.append(process) for process in processes: process.join() if __name__ == '__main__': start_time = time.time() main() end_time = time.time() print(f\"Execution time: {end_time - start_time:.2f} seconds\") # 36.76","title":"multiprocessing"},{"location":"LR2/#_2","text":"Program Time async 20.71 threading 33.34 multiprocessing 36.76 \u0410\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 (async) \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043d\u0430\u0438\u0431\u043e\u043b\u0435\u0435 \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u044b\u043c \u043f\u043e\u0434\u0445\u043e\u0434\u043e\u043c \u0434\u043b\u044f \u0437\u0430\u0434\u0430\u0447\u0438 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0430 \u0432\u0435\u0431-\u0441\u0442\u0440\u0430\u043d\u0438\u0446 \u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0434\u0430\u043d\u043d\u044b\u0445 \u0432 \u0431\u0430\u0437\u0443 \u0434\u0430\u043d\u043d\u044b\u0445, \u043e\u0441\u043e\u0431\u0435\u043d\u043d\u043e \u043a\u043e\u0433\u0434\u0430 \u0437\u0430\u0434\u0430\u0447\u0430 \u0432\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u043c\u043d\u043e\u0433\u043e I/O \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0439, \u0442\u0430\u043a\u0438\u0445 \u043a\u0430\u043a \u0437\u0430\u043f\u0440\u043e\u0441\u044b \u043a \u0432\u0435\u0431-\u0441\u0435\u0440\u0432\u0435\u0440\u0430\u043c. \u041f\u043e\u0434\u0445\u043e\u0434 threading \u0442\u0430\u043a\u0436\u0435 \u043f\u043e\u043a\u0430\u0437\u0430\u043b \u0445\u043e\u0440\u043e\u0448\u0438\u0435 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0438 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043f\u0440\u0435\u0434\u043f\u043e\u0447\u0442\u0438\u0442\u0435\u043b\u0435\u043d \u0434\u043b\u044f \u043f\u0440\u043e\u0441\u0442\u044b\u0445 \u0437\u0430\u0434\u0430\u0447 \u0438\u043b\u0438 \u043a\u043e\u0433\u0434\u0430 \u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043d\u0435 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u043e. Multiprocessing, \u0445\u043e\u0442\u044f \u0438 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043f\u043e\u043b\u0435\u0437\u043d\u044b\u043c \u0434\u043b\u044f CPU-\u0438\u043d\u0442\u0435\u043d\u0441\u0438\u0432\u043d\u044b\u0445 \u0437\u0430\u0434\u0430\u0447, \u043e\u043a\u0430\u0437\u0430\u043b\u0441\u044f \u043c\u0435\u043d\u0435\u0435 \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u044b\u043c \u0434\u043b\u044f \u0434\u0430\u043d\u043d\u043e\u0439 \u0437\u0430\u0434\u0430\u0447\u0438 \u0438\u0437-\u0437\u0430 \u0431\u043e\u043b\u044c\u0448\u0438\u0445 \u043d\u0430\u043a\u043b\u0430\u0434\u043d\u044b\u0445 \u0440\u0430\u0441\u0445\u043e\u0434\u043e\u0432 \u043d\u0430 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430\u043c\u0438.","title":"\u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442"}]}